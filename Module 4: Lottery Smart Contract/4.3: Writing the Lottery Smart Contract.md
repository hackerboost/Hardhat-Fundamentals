## Introduction

Now that we have our project set up, it's time to start writing the core logic for our **Lottery Smart Contract**. We’ll implement key functions that allow users to enter the lottery, manage ticket fees, and select a winner using on-chain randomness.

## Objectives
In this lesson, you will:
- Write the `enter()` function to handle user entries.
- Implement a mechanism to collect ticket fees and store player addresses.
- Set up a function to generate randomness for winner selection.

---

### Step 1: Understand the State Variables and Constructor

1. **Open `Lottery.sol`** in your `contracts` folder.
2. The state variables keep track of important information in the contract:
   ```solidity
   // SPDX-License-Identifier: MIT
   pragma solidity ^0.8.0;

   /**
    * @title A Lottery Contract
    * @notice This contract allows users to enter a lottery and win prizes
    */
   contract Lottery {
    // Declare state variables
    address public manager; // stores the address of the contract manager
    address payable[] public currentPlayers; // Stores players for the current round
    address[] public allPlayers; // Stores all players across all rounds
    address payable public winner; // stores the address of the winner of each round.
    bool public isComplete; // shows the current status of a round.

    // Events
    event WinnerPicked(address indexed winner);

    // Constructor
    constructor() {
        manager = msg.sender;
        isComplete = false;
    }
   }
   ```

---

### Step 2: Writing the `enter()` Function

The `enter()` function allows users to join the lottery by sending a minimum amount of Ether. We’ll use Solidity’s `msg.value` to check the amount sent and `payable(msg.sender)` to record the user’s address.

1. **Add the `enter()` function**:
```solidity
function enter() public payable {
    require(msg.value >= 0.001 ether, "Minimum entry fee is 0.001 ether");
    require(!isComplete, "Lottery is complete");

    // Add player to current round and overall history
    currentPlayers.push(payable(msg.sender));
    allPlayers.push(msg.sender);
}
```

### Explanation
- **require()**: Ensures that the player sends at least 0.001 Ether to enter the lottery and that the lottery is not already complete. If the condition is not met, the transaction will revert.
- **payable(msg.sender)**: Converts the sender’s address into a payable address so that we can later send Ether to the winner.

---

### Step 3: Writing the `pickWinner()` Function

The `pickWinner()` function is responsible for selecting a winner using on-chain randomness. We’ll generate a random number using blockchain data.

1. **Add the `pickWinner()` function**:
```solidity
function pickWinner() public onlyManager {
    require(currentPlayers.length > 0, "No players in the lottery");
    require(!isComplete, "Lottery is complete");

    uint randomIndex = randomNumber() % currentPlayers.length;
    winner = currentPlayers[randomIndex];
    isComplete = true;
    emit WinnerPicked(winner);

    // Reset the currentPlayers array
    delete currentPlayers;
}
```

2. **Add the `onlyManager()` modifier**:
```solidity
modifier onlyManager() {
    require(msg.sender == manager, "Only the manager can call this function");
    _;
}
```

### Explanation
- **onlyManager Modifier**: Ensures that only the manager can call `pickWinner()`.
- **require()**: Checks that there are players in the lottery and that the lottery is not already complete.
- **Random Index**: The winner is selected using a random index generated by the `randomNumber()` function.

---

### Step 4: Adding the `randomNumber()` Function

1. **Add the `randomNumber()` function**:
   ```solidity
    function randomNumber() private view returns (uint) {
        return uint(keccak256(abi.encodePacked(block.prevrandao, block.timestamp, currentPlayers.length)));
    }
   ```

### Explanation
- **block.prevrandao**: Provides a pseudo-random value based on the previous block’s randomness.
- **block.timestamp**: Adds variability based on the current block timestamp.
- **currentPlayers.length**: Introduces variability based on the number of players.

---

### Step 5: Adding the `claimPrize()` Function

The `claimPrize()` function allows the winner to claim their prize by transferring the Ether balance of the contract to their address.

1. **Add the `claimPrize()` function**:
   ```solidity
   function claimPrize() public {
        require(msg.sender == winner, "You are not the winner");
        require(isComplete, "Lottery is not complete");
        winner.transfer(address(this).balance);

        // Reset the lottery state
        isComplete = false;
    }
   ```

### Explanation
- **Winner Check**: Ensures that only the winner can claim the prize.
- **isComplete Check**: Ensures that the lottery is marked as complete before the prize can be claimed.
- **Transfer Funds**: Transfers the contract’s Ether balance to the winner’s address.

---

### Step 6: Adding the `getCurrentPlayers()` Function

1. **Add the `getCurrentPlayers()` function**:
   ```solidity
   function getCurrentPlayers() public view returns (address payable[] memory) {
        return currentPlayers;
    }
   ```

### Explanation
- This function allows anyone to view the list of players currently in the lottery.

---

### Step 7: Adding the `getAllPlayers()` Function

1. **Add the `getAllPlayers()` function**:
   ```solidity
   function getAllPlayers() public view returns (address[] memory) {
        return allPlayers;
    }
   ```

### Explanation
- This function allows anyone to view the list of all players who have ever participated in any lottery round.

---

## Wrapping Up

Congratulations! You’ve successfully written the core functionality of the Lottery Smart Contract. In the next lesson, we’ll test our contract and deploy it to the Arbitrum test network.

